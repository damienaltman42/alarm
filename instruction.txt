# ğŸ“Œ Projet de RÃ©veil Intelligent avec Radio en React Native (Expo + TypeScript)

**Contexte du projet**  
Nous dÃ©veloppons une application de rÃ©veil (aurora-wake) avancÃ©e en **React Native (Expo)** qui permettra aux utilisateurs de **configurer des alarmes rÃ©veil** avec une **station de radio** Ã  la place d'une sonnerie classique.  

### **ğŸ“Œ SpÃ©cifications du projet**  
1. **Gestion complÃ¨te des alarmes**  
   - Ajouter, modifier et supprimer une alarme.  
   - SÃ©lectionner l'heure et les jours de rÃ©pÃ©tition (ex: rÃ©veil chaque lundi et jeudi).  
   - Activer/dÃ©sactiver une alarme avec un **switch toggle**.  
   - Stockage local des alarmes (AsyncStorage ou SQLite).  

2. **Mode Radio**  Documentation dans le fichier "DOC-API-Radio-Browser.md"
   - L'utilisateur choisit une station de radio pour chaque alarme.  
   - IntÃ©gration de **l'API Radio-Browser** pour rechercher les radios en fonction (DOC-API-Radio-Browser.md):  
     - Du genre musical ğŸµ  
     - Du pays ğŸŒ  
     - Du nom de la station ğŸ”  
   - Lecture de la radio avec **expo-av**, support du mode **arriÃ¨re-plan**.  
   - La radio sÃ©lectionnÃ©e dÃ©marre automatiquement Ã  l'heure de l'alarme.  

3. **Notifications et rÃ©veil**  
   - L'alarme dÃ©clenche une **notification locale** Ã  l'heure prÃ©vue.  
   - L'utilisateur peut **arrÃªter ou snoozer** via la notification.  
   - L'**Ã©cran se rÃ©veille** si l'appareil le permet (iOS).  

4. **Interface moderne et ergonomique**  
   - **Navigation fluide** avec React Navigation.  
   - Design minimaliste et **mode sombre/clair auto**.  
   - Animations (ex: transition douce entre les Ã©crans, animation du toggle d'alarme).  

### **ğŸ“‚ Structure du projet optimisÃ©e**  
Le projet doit suivre une architecture modulaire et Ã©volutive :

```
src/
â”œâ”€â”€ api/                  # Couche d'accÃ¨s aux donnÃ©es externes
â”‚   â”œâ”€â”€ radioApi.ts       # API pour les stations de radio
â”‚   â””â”€â”€ storageApi.ts     # API pour le stockage local
â”‚
â”œâ”€â”€ components/           # Composants UI rÃ©utilisables
â”‚   â”œâ”€â”€ common/           # Composants gÃ©nÃ©riques (boutons, inputs, etc.)
â”‚   â”œâ”€â”€ alarm/            # Composants spÃ©cifiques aux alarmes
â”‚   â””â”€â”€ radio/            # Composants spÃ©cifiques aux radios
â”‚
â”œâ”€â”€ hooks/                # Hooks personnalisÃ©s
â”‚   â”œâ”€â”€ useAlarm.ts
â”‚   â”œâ”€â”€ useRadio.ts
â”‚   â””â”€â”€ useTheme.ts
â”‚
â”œâ”€â”€ services/             # Services mÃ©tier
â”‚   â”œâ”€â”€ alarm/
â”‚   â”‚   â”œâ”€â”€ alarmScheduler.ts
â”‚   â”‚   â”œâ”€â”€ alarmStorage.ts
â”‚   â”‚   â””â”€â”€ alarmPlayer.ts
â”‚   â”œâ”€â”€ radio/
â”‚   â”‚   â”œâ”€â”€ radioFinder.ts
â”‚   â”‚   â”œâ”€â”€ radioPlayer.ts
â”‚   â”‚   â””â”€â”€ radioFavorites.ts
â”‚   â””â”€â”€ notification/
â”‚       â””â”€â”€ notificationService.ts
â”‚
â”œâ”€â”€ screens/              # Ã‰crans de l'application
â”‚   â”œâ”€â”€ alarm/
â”‚   â”‚   â”œâ”€â”€ AlarmListScreen.tsx
â”‚   â”‚   â””â”€â”€ AlarmEditScreen.tsx
â”‚   â””â”€â”€ radio/
â”‚       â””â”€â”€ RadioSearchScreen.tsx
â”‚
â”œâ”€â”€ navigation/           # Configuration de la navigation
â”‚   â”œâ”€â”€ AppNavigator.tsx
â”‚   â””â”€â”€ navigationTypes.ts
â”‚
â”œâ”€â”€ contexts/             # Contextes React
â”‚   â”œâ”€â”€ AlarmContext.tsx
â”‚   â”œâ”€â”€ RadioContext.tsx
â”‚   â””â”€â”€ ThemeContext.tsx
â”‚
â”œâ”€â”€ types/                # Types et interfaces
â”‚   â”œâ”€â”€ alarm.ts
â”‚   â”œâ”€â”€ radio.ts
â”‚   â””â”€â”€ settings.ts
â”‚
â””â”€â”€ utils/                # Fonctions utilitaires
    â”œâ”€â”€ dateUtils.ts
    â”œâ”€â”€ audioUtils.ts
    â””â”€â”€ errorHandling.ts
```

### **ğŸ”§ Contraintes Techniques**  
- **React Native avec Expo (workflow gÃ©rÃ©).**  
- **TypeScript** obligatoire.  
- **expo-av** pour la lecture audio.  
- **expo-notifications** pour les alarmes.  
- **API Radio-Browser** pour rÃ©cupÃ©rer les stations de radio.  
- **Stockage des alarmes** avec AsyncStorage ou SQLite.  

### **ğŸš€ Bonnes pratiques Ã  suivre**  
1. **SÃ©paration des prÃ©occupations**
   - SÃ©parer la logique mÃ©tier de l'interface utilisateur
   - Utiliser des hooks personnalisÃ©s pour encapsuler la logique rÃ©utilisable
   - Limiter la taille des fichiers Ã  200-300 lignes maximum

2. **Gestion de l'Ã©tat**
   - Utiliser les contextes React pour l'Ã©tat global
   - PrÃ©fÃ©rer les Ã©tats locaux quand c'est possible
   - ImplÃ©menter des reducers pour les logiques d'Ã©tat complexes

3. **Gestion des erreurs**
   - CrÃ©er un service centralisÃ© de gestion des erreurs
   - Utiliser try/catch pour les opÃ©rations asynchrones
   - Fournir des messages d'erreur clairs Ã  l'utilisateur

4. **Tests**
   - Ã‰crire des tests unitaires pour les services critiques
   - Tester les composants UI avec React Testing Library
   - Viser une couverture de code d'au moins 70%

### **ğŸ“Œ Refactorisation des fichiers volumineux**
Pour les fichiers identifiÃ©s comme trop volumineux :

1. **AlarmManager.ts**
   - Diviser en services spÃ©cialisÃ©s (alarmScheduler.ts, alarmStorage.ts, alarmPlayer.ts)
   - Utiliser des classes avec responsabilitÃ© unique
   - ImplÃ©menter des interfaces claires

2. **RadioService.ts**
   - SÃ©parer en services spÃ©cifiques (radioApi.ts, radioCache.ts, radioSearch.ts)
   - GÃ©rer le cache et les erreurs de maniÃ¨re centralisÃ©e
   - Utiliser des patterns asynchrones modernes (async/await)

3. **RadioSearch.tsx et AddAlarmScreen.tsx**
   - Extraire des composants plus petits et rÃ©utilisables
   - Utiliser la composition de composants
   - SÃ©parer la logique de prÃ©sentation de la logique mÃ©tier

### **ğŸ“Œ Livrable attendu**  
Une application React Native complÃ¨te avec :
- Architecture modulaire suivant les bonnes pratiques
- Code bien commentÃ© et maintenable
- Composants rÃ©utilisables et testables
- Documentation claire pour les dÃ©veloppeurs


